Реализовать функцию для декодирования данных, содержащих битовые поля. В решении необходимо использовать побитовые операции. Неиспользуемые поля результата должны содержать нулевые биты.

Входные данные:

![image](https://github.com/mir4sem/python/assets/70198995/be2fdc6b-3634-44da-9837-b30c64b2c96f)

Выходные данные:

Кортеж из битовых полей в порядке от младших бит к старшим. Значения битовых полей имеют тип: шестнадцатиричная строка.

Тесты:

main('12930800291')
<br>
('0xa3', '0x5a', '0x4', '0x2b', '0xc')

main('5491355607')
<br>
('0xd7', '0x6f', '0x7', '0x74', '0x5')

main('4385472263')
<br>
('0x7', '0xff', '0x4', '0x56', '0x4')

main('8283508376')
<br>
('0x98', '0x4e', '0x4', '0x2db', '0x7')

### Объъяснение
поле = (число >> смещение) & маска

- поле - это переменная, в которую мы сохраняем извлечённое битовое поле.
- число - это исходное число, из которого мы извлекаем битовое поле.
- смещение - это количество бит, на которое нужно сдвинуть число вправо.
- маска - это двоичное число, которое определяет, какие биты нужно оставить после сдвига.

```python
def main(data):
    num = int(data)
    E1 = num & 0xFF  # смещение 0 (нет), маска 1111 1111
    E2 = (num >> 8) & 0xFF  # смещение 8, маска 1111 1111
    E3 = (num >> 16) & 0x7  # смещение 16, маска 111
    E5 = (num >> 20) & 0x3FF  #  смещение 20, маска 11 1111 1111
    E6 = (num >> 30) & 0xF  # смещение 30, маска 111
    E1_hex = hex(E1)
    E2_hex = hex(E2)
    E3_hex = hex(E3)
    E5_hex = hex(E5)
    E6_hex = hex(E6)
    return (E1_hex, E2_hex, E3_hex, E5_hex, E6_hex)

```

```python
def main(input_string):
    input_int = int(input_string)
    hex_representation1 = hex(input_int & 0xFF)
    hex_representation2 = hex((input_int >> 8) & 0xFF)
    hex_representation3 = hex((input_int >> 16) & 0x7)
    hex_representation4 = f"0x{((input_int >> 20) & 0x3FF):3x}"
    hex_representation4 = hex_representation4.replace(" ", "")
    hex_representation5 = hex((input_int >> 30) & 0xFF)
    res = (hex_representation1, hex_representation2,
           hex_representation3, hex_representation4, hex_representation5)
    return res

```

# 1 Вариант
![image](https://github.com/mir4sem/python/assets/70198995/596a949b-1417-49f3-985b-6d4000c80c4f)

```python
def main(data):
    # Преобразуем входные строки в целые числа
    T1, T2, T3, T4 = map(int, data)

    # Сдвигаем битовые поля на соответствующие позиции
    T1 <<= 0  # T1 уже на месте
    T2 <<= 4  # Сдвигаем T2 на 3 бита влево
    T3 <<= 5  # Сдвигаем T3 на 5 бит влево
    T4 <<= 12 # Сдвигаем T4 на 11 бит влево

    # Объединяем битовые поля с помощью побитовой операции ИЛИ
    result = T1 | T2 | T3 | T4

    # Преобразуем результат в шестнадцатеричную строку
    return hex(result)

# Тесты
print(main(('1', '1', '55', '0')))  # '0x6f1'
print(main(('12', '1', '27', '2'))) # '0x237c'
print(main(('5', '0', '81', '13'))) # '0xda25'
print(main(('12', '0', '13', '2'))) # '0x21ac'
```

# 2 вариант
![image](https://github.com/mir4sem/python/assets/70198995/0585a625-017e-4d7c-9969-609f904d109e)

```python
def main(num):
    # Извлекаем значения битовых полей
    F1 = num & 0x7F  # Биты 0-5, маска 111 1111 
    F2 = (num >> 7) & 0x7  # Биты 6-8, маска 111
    F3 = (num >> 10) & 0x1  # Биты 9-10, маска 1

    # Создаем список пар имя-значение
    result = [('F1', F1), ('F2', F2), ('F3', F3)]

    return result

# Тесты
print(main(405))     # [('F1', 21), ('F2', 3), ('F3', 0)]
print(main(1525))    # [('F1', 117), ('F2', 3), ('F3', 1)]
print(main(893))     # [('F1', 125), ('F2', 6), ('F3', 0)]
print(main(549))     # [('F1', 37), ('F2', 4), ('F3', 0)]
```

# 3 вариант
![image](https://github.com/mir4sem/python/assets/70198995/7793b74c-57d6-486e-9b65-4f5f1be3eef3)

```python
def main(fields):
    # Преобразуем входные строки в целые числа
    field_dict = {name: int(value, 16) for name, value in fields}

    # Извлекаем значения полей
    L2 = field_dict['L2']
    L3 = field_dict['L3']
    L4 = field_dict['L4']

    # Сдвигаем битовые поля на соответствующие позиции
    L2 <<= 1  # L2 уже на месте
    L3 <<= 6  # Сдвигаем L3 на 6 бит влево
    L4 <<= 13 # Сдвигаем L4 на 12 бит влево

    # Объединяем битовые поля с помощью побитовой операции ИЛИ
    result = L2 | L3 | L4

    # Возвращаем результат
    return result

# Тесты
print(main([('L2', '0x10'), ('L3', '0xa'), ('L4', '0x2f')]))  # 385696
print(main([('L2', '0x10'), ('L3', '0x5f'), ('L4', '0x1ac')])) # 3512288
print(main([('L2', '0x2'), ('L3', '0x15'), ('L4', '0x305')])) # 6333764
print(main([('L2', '0x15'), ('L3', '0x7'), ('L4', '0x397')]))  # 7528938
```

# 4 вариант
![image](https://github.com/mir4sem/python/assets/70198995/de492864-bc34-4772-8b29-36126c587e09)

```python
def main(fields):
    # Преобразуем входные строки в целые числа
    field_dict = [int(value, 16) for value in fields]

    # Извлекаем значения полей
    N1, N2, N3, N4, N5 = field_dict

    # Сдвигаем битовые поля на соответствующие позиции
    N1 <<= 0   # N1 уже на месте
    N2 <<= 3   # Сдвигаем N2 на 3 бита влево
    N3 <<= 6   # Сдвигаем N3 на 6 бит влево
    N4 <<= 13  # Сдвигаем N4 на 13 бит влево
    N5 <<= 21  # Сдвигаем N5 на 21 бит влево

    # Объединяем битовые поля с помощью побитовой операции ИЛИ
    result = N1 | N2 | N3 | N4 | N5

    # Возвращаем результат в виде десятичной строки
    return str(result)

# Тесты
print(main(('0x2', '0x4', '0x19', '0x21', '0xd')))  # Ожидается: '27534946'
print(main(('0x3', '0x7', '0x71', '0x12', '0x27'))) # Ожидается: '81938043'
print(main(('0x7', '0x4', '0xe', '0xbe', '0x1d')))  # Ожидается: '62374311'
print(main(('0x0', '0x1', '0x1b', '0x67', '0x34'))) # Ожидается: '109897408'
```

# 5 вариант
![image](https://github.com/mir4sem/python/assets/70198995/9b8fb5de-518f-4210-b9af-c12e0e4de1c9)

```python
def main(data):
    # Преобразуем входную строку в целое число
    num = int(data)

    # Извлекаем значения битовых полей
    J1 = num & 0x1F      # Биты 0-4 (5 бит)
    J2 = (num >> 5) & 0x3F  # Биты 5-10 (6 бит)
    J3 = (num >> 11) & 0x3FF # Биты 11-21 (11 бит)

    # Сдвигаем битовые поля на новые позиции
    J1 <<= 16  # Сдвигаем J1 на 16 бит влево (биты 20-21)
    J2 <<= 10   # Сдвигаем J2 на 9 бит влево (биты 15-9)
    J3 >>= 0   # J3 сдвигаем на 0 бит, т.е. оставляем на месте (биты 9-0)

    # Объединяем битовые поля с помощью побитовой операции ИЛИ
    result = J1 | J2 | J3

    # Возвращаем результат
    return result

# Тесты
print(main('821747'))   # Ожидается: 1260945
print(main('361091'))   # Ожидается: 217264
print(main('1660895'))  # Ожидается: 2095914
print(main('1033969'))  # Ожидается: 1170936
```

![image](https://github.com/mir4sem/python/assets/70198995/62d277b0-43c3-4d1d-86f6-0db08d3a9687)

```python
def main(fields):
    # Преобразуем входные строки в целые числа
    field_dict = {name: int(value, 16) for name, value in fields}

    # Извлекаем значения полей
    H1 = field_dict['H1']
    H3 = field_dict['H3']
    H4 = field_dict['H4']
    H5 = field_dict['H5']
    H6 = field_dict['H6']

    # Сдвигаем битовые поля на соответствующие позиции
    H1 <<= 0    # H1 уже на месте
    H3 <<= 13   # Сдвигаем H3 на 13 бит влево
    H4 <<= 21   # Сдвигаем H4 на 21 бит влево
    H5 <<= 24   # Сдвигаем H5 на 24 бит влево
    H6 <<= 34   # Сдвигаем H6 на 34 бит влево

    # Объединяем битовые поля с помощью побитовой операции ИЛИ
    result = H1 | H3 | H4 | H5 | H6

    # Возвращаем результат в виде шестнадцатеричной строки
    return hex(result)

# Тесты
print(main([('H1', '0x35'), ('H3', '0x2e'), ('H4', '0x2'), ('H5', '0x336'), ('H6', '0x62')]))  # '0x18b362b8035'
print(main([('H1', '0x3e'), ('H3', '0x2e'), ('H4', '0x5'), ('H5', '0x3b'), ('H6', '0x4')]))    # '0x103b5b803e'
print(main([('H1', '0xa'), ('H3', '0x20'), ('H4', '0x5'), ('H5', '0x367'), ('H6', '0xcd')]))   # '0x3376758000a'
print(main([('H1', '0x12'), ('H3', '0x36'), ('H4', '0x8'), ('H5', '0xd9'), ('H6', '0xfd')]))   # '0x3f4d98d8012'
```
